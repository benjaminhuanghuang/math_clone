from app.models.user import User
from app import login_manager
from flask import current_app
# Python module which helps securely sign cookies
from itsdangerous import URLSafeTimedSerializer

login_serializer = URLSafeTimedSerializer(current_app.config["SECRET_KEY"])

@login_manager.user_loader
def load_user(user_id):
    '''
    Flask-Login user_loader callback.
    The user_loader function asks this function to get a User Object or return
    None based on the user_id.
    The user_id was stored in the session environment by Flask-Login.
    user_loader stores the returned User object in current_user during every
    flask request.
    To be used load user object from session when access URL
    :param user_id:  Should be the same as user.get_id()
    '''
    user = User.get_user_by_id(user_id)
    if user:
        return User(user)
    return None

@login_manager.token_loader
def load_token(token):
    """
    Flask-Login token_loader callback.
    The token_loader function asks this function to take the token that was
    stored on the users computer process it to check if its valid and then
    return a User Object if its valid or None if its not valid.
    """

    #The Token itself was generated by User.get_auth_token.  So it is up to
    #us to known the format of the token data itself.

    #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which
    #allows us to have a max_age on the token itself.  When the cookie is stored
    #on the users computer it also has a exipry date, but could be changed by
    #the user, so this feature allows us to enforce the exipry date of the token
    #server side and not rely on the users cookie to exipre.
    max_age = current_app.config["COOKIE_DURATION"].total_seconds()

    #Decrypt the Security Token, data = [username, hashpass]
    try:
        data = login_serializer.loads(token, max_age=max_age)
    except:
        return None
    #Find the User
    user_id = data[0]
    hashed_password = data[1]
    user = User.get(user_id)

    #Check Password and return user or None
    if user and hashed_password == user.password:
        return user
    return None
